#ifndef WORKER_POOL_H
#define WORKER_POOL_H

#include <memory>
#include <set>
#include <vector>
#include <thread>
#include <stdexcept>
#include <atomic>
#include <functional>
#include <future>


#include "Processor.h"
#include "TypePolicies.h"
#include "Core.h"
#include "NUMANode.h"
#include "WorkQueue.h"

namespace dxpool {

class InvalidWorkerPoolBuilderArgumentsError: public std::invalid_argument {
    using std::invalid_argument::invalid_argument;
};

class WorkerPoolBuilder;

/**
 * @brief A worker pool creates a static pool of threads with a given CPU affinity.
 * The number of threads in the pool do not change during its lifetime.
 *
 * Tasks can be submitted for execution via the methods Submit but will only be executed when one of the threads becomes available.
 * This means tasks can starve or never be executed if threads are doing long duration processing, locked or in an infinite loop.
 *
 * Worker threads will lock and wait until there's work to do.
 *
 *
 * A WorkerPool instance can only be create via the WorkerPoolBuilder
 */
class WorkerPool final {
  private:
    friend WorkerPoolBuilder;

    std::vector<std::thread> threads;
    WorkQueue workQueue;
    std::atomic_bool isAlive{true};

    auto startThread(const Core core) -> void {
        Processor processor;
        processor.SetThreadAffinity({core});

        while(this->isAlive) {
            auto task = this->workQueue.Take();
            task();
        }
    }

    auto buildWorkerPool(unsigned int threadsPerCore, const std::set<Core>& cores) -> void {
        for(const Core& core: cores) {
            for(unsigned int threadNum = 0 ; threadNum < threadsPerCore ; threadNum++) {
                this->threads.emplace_back(
                [core, this]() {
                    this->startThread(core);
                });
            }
        }
    }

    WorkerPool(unsigned int threadsPerCore, const std::set<Core>& cores) {
        this->buildWorkerPool(threadsPerCore, cores);
    }
  public:
    WorkerPool() = delete;

    /**
     * @brief Submits a task for execution providing a promise that can be used to obtain a result generated by the task
     *
     * @tparam Callable type of the task
     * @tparam Result type of the result returned
     * @tparam Args type of the arguments to be passed to the task
     * @param task the task to be executed
     * @param args arguments to be passed to the task
     * @return std::future<Result> future containing a result generated by the task
     */
    template<typename Callable, typename Result, typename... Args>
    auto Submit(Callable&& task, Args&&... args) -> std::future<Result> {
        std::shared_ptr<std::promise<Result>> taskPromise = std::make_shared<std::promise<Result>>();

        std::future<Result> futureRes = taskPromise->get_future();
        auto threadTask = [taskPromise, task, args...]  () {
            Result res = task(args...);
            taskPromise->set_value(res);
        };

        this->workQueue.Add(std::move(threadTask));
        return futureRes;
    }

    /**
     * @brief Submits at task for execution
     *
     * @param task  to be executed
     */
    auto Submit(WorkQueue::WorkerTask&& task) -> void {
        this->workQueue.Add(std::move(task));
    }

    /**
     * @brief Returns the number of workers (threads) in the pool
     *
     * @return size_t number of workers in the pool
     */
    auto Size() const -> size_t {
        return this->threads.size();
    }

    /**
     * @brief Waits for all workers to finish and stops all threads
     *
     */
    auto Shutdown() -> void {
        if(!isAlive) {
            return;
        }

        this->isAlive = false;
        // to shutdown properly, add as many (noop) tasks as threads and join on each

        for(size_t i = 0 ; i < this->threads.size(); i++) {
            this->Submit([] {});
        }

        for(auto& thread: this->threads) {
            thread.join();
        }
    }

    /**
     * @brief Determins if the pool has work to do by checking if there are items in the task list.
     * Note that this doesn't mean all workers (threads) are idle, only that there are no tasks pending execution
     * @return true if the pool has work to do
     * @return false otherwise
     */
    auto HasWork() -> bool {
        return this->workQueue.HasWork();
    }

    FORBID_COPY_MOVE_ASSIGN(WorkerPool);

    /**
     * @brief When destructed, the worker pool will wait for all tasks to finish and stop (join) all threads
     *
     */
    ~WorkerPool() {
        this->Shutdown();
    };

}; // class WorkerPool


/**
 * @brief Builder for worker pool
 *
 */
class WorkerPoolBuilder final {
  private:
    std::set<Core> cpuCores;
    NUMANode numaNode{};
    unsigned int threadsPerCore{0};
  public:
    /**
     * @brief Set the number of threads per core for each core specified via OnCores or OnNumaNode
     *
     *
     * @param num Number of threads per core. Minimum of 1
     * @return This thread pool builder
     */
    auto WithThreadsPerCore(unsigned int num)-> WorkerPoolBuilder& {
        this->threadsPerCore = num;
        return *this;
    }

    /**
     * @brief Sets the cores to which the created threads will have affinity
     *
     * Cannot be used together with OnNumaNode
     *
     * @param cores Set of cores to be used. At least one core is required
     * @return This thread pool builder
     */
    auto OnCores(const std::set<Core>& cores)-> WorkerPoolBuilder& {
        this->cpuCores = cores;
        return *this;
    }

    /**
     * @brief Sets the cores to which the created threads will have affinity given a NUMA node.
     * All cores linked to the given NUMA node will have at least one thread (as specified via WithThreadsPerCore)
     * with affinity to it
     *
     * Cannot be used together with OnCores
     *
     * @param node a numa node representation
     * @return this builder
     */
    auto OnNUMANode(const NUMANode& node)-> WorkerPoolBuilder& {
        this->numaNode = node;
        return *this;
    }

    /**
     * @brief Threads per core specified to the builder
     *
     * @return Number of threads per core
     */
    auto ThreadsPerCore() const -> unsigned int {
        return this->threadsPerCore;
    }

    /**
     * @brief Cores specified to the builder
     *
     * @return Set of Cores
     */
    auto Cores() const -> const std::set<Core>& {
        return this->cpuCores;
    }

    /**
     * @brief Numa node specified to the builder
     *
     * @return The NUMANode object
     */
    auto TargetNUMANode() const -> NUMANode  {
        return this->numaNode;
    }

    /**
     * @brief Builds a thread pool given the specified parameters
     *
     * @throws InvalidWorkerPoolBuilderArguments if the specified are not valid or incompatible
     * @return A WorkerPool object
     */
    auto Build() const noexcept(false) -> std::unique_ptr<WorkerPool> {
        if(this->threadsPerCore<1) {
            throw InvalidWorkerPoolBuilderArgumentsError("At least one thread per core needs to be specified");
        }

        if(this->cpuCores.empty() && this->numaNode.Empty()) {
            throw InvalidWorkerPoolBuilderArgumentsError("At least one of cores or NUMA node must be specified");
        }

        if(!this->cpuCores.empty() && !this->numaNode.Empty()) {
            throw InvalidWorkerPoolBuilderArgumentsError("Only one of cores or NUMA can be specified");
        }

        return std::unique_ptr<WorkerPool>(new WorkerPool(this->threadsPerCore,
        [this]() -> std::set<Core> {
            if(!this->cpuCores.empty()) {
                return this->Cores();
            }

            return this->numaNode.Cores();
        }
        ()));
    }
};

} // namespace dxpool

#endif // WORKER_POOL_H